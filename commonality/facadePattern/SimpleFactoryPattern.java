package com.rxjava.commonality.facadePattern;

/**
 * 作者：wanglei on 17/10/26 10:45
 * 邮箱：229846388@qq.com
 * 外观模式
 * 定义:
 * 1.定义了一个高层、统一的接口，外部与通过这个统一的接口对子系统中的一群接口进行访问。
 * 2.通过创建一个统一的类，用来包装子系统中一个或多个复杂的类，客户端可以通过调用外观类的方法来调用内部子系统中所有方法
 * 主要作用:
 * 1.实现客户类与子系统类的松耦合
 * 2.降低原有系统的复杂度
 * 3.提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。
 * 4.引入外观角色之后，用户只需要与外观角色交互；
 * 5.用户与子系统之间的复杂逻辑关系由外观角色来实现
 * 解决的问题:
 * 1.避免了系统与系统之间的高耦合度
 * 2.使得复杂的子系统用法变得简单
 * 实例讲解:
 * a. 实例概况
 * 背景：小成的爷爷已经80岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；
 * 冲突：行动不方便，走过去关闭那么多电器很麻烦：
 */
public class SimpleFactoryPattern {
    public static void main(String[] args) {
        //实例化电器类
        SubSystemA_Light light = new SubSystemA_Light();
        SubSystemB_Television television = new SubSystemB_Television();
        SubSystemC_Aircondition aircondition = new SubSystemC_Aircondition();

        Facade facade = new Facade(light,television,aircondition);
        facade.on();
        facade.off();
    }
}

/**
 * 结果:
 * get up ......
 * 开灯......
 * 开电视......
 * 开空调......
 * sleep ......
 * 关灯......
 * 关电视......
 * 关空调......
 * 优点:
 * 1.降低了客户类与子系统类的耦合度，实现了子系统与客户之间的松耦合关系
 * 2.只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类
 * 3.减少了与子系统的关联对象，实现了子系统与客户之间的松耦合关系，松耦合使得子系统的组件变化不会影响到它的客户。
 * 4.外观模式对客户屏蔽了子系统组件，从而简化了接口，减少了客户处理的对象数目并使子系统的使用更加简单。
 * 5.入外观角色之后，用户只需要与外观角色交互；
 * 6.用户与子系统之间的复杂逻辑关系由外观角色来实现
 * 7.降低原有系统的复杂度和系统中的编译依赖性，并简化了系统在不同平台之间的移植过程
 * 8.编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。
 * 缺点:
 * 1.在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”
 * 2.不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了
 * 应用场景:
 * 1.要为一个复杂的子系统对外提供一个简单的接口
 * 2.提供子系统的独立性
 * 3.客户程序与多个子系统之间存在很大的依赖性:引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。
 * 4.在层次化结构中，可以使用外观模式定义系统中每一层的入口
 * 5.层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。
 * 与适配器模式的区别:
 * 1.外观模式的实现核心主要是——由外观类去保存各个子系统的引用，实现由一个统一的外观类去包装多个子系统类，然而客户端只需要引用这个外观类，然后由外观类来调用各个子系统中的方法。
 * 2.这样的实现方式非常类似适配器模式，然而外观模式与适配器模式不同的是：适配器模式是将一个对象包装起来以改变其接口，而外观是将一群对象 ”包装“起来以简化其接口。它们的意图是不一样的，适配器是将接口转换为不同接口，而外观模式是提供一个统一的接口来简化接口。
 */