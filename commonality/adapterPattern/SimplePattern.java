package com.rxjava.commonality.adapterPattern;

/**
 * 作者：wanglei on 17/10/26 11:31
 * 邮箱：229846388@qq.com
 * 适配器模式
 * 定义:
 * 1.适配器模式，即定义一个包装类，用于包装不兼容接口的对象
 * 2.包装类 = 适配器Adapter；
 * 3.被包装对象 = 适配者Adaptee = 被适配的类
 * 主要作用:
 * 1.把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。
 * 2.适配器模式的形式分为：类的适配器模式和对象的适配器
 * 解决的问题:
 * 1.原本由于接口不兼容而不能一起工作的那些类可以在一起工作。
 * 类的适配器模式:
 * 1.类的适配器模式:是把适配的类的API转换成为目标类的API。
 * 2.对象的适配器模式:与类的适配器模式相同，对象的适配器模式也是把适配的类的API转换成为目标类的API。与类的适配器模式不同的是，对象的适配器模式不是使用继承关系连接到Adaptee类，而是使用委派关系连接到Adaptee类。
 */
public class SimplePattern {
    public static void main(String[] args) {
        Target adapter1 = new Adapter1();
        adapter1.Request();

        //需要先创建一个被适配类的对象作为参数
        Target adapter2 = new Adapter2(new Adaptee());
        adapter2.Request();

    }
}

/**
 * 优点:
 * 1.更好的复用性:系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。
 * 2.透明、简单:客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单 & 更直接
 * 3.更好的扩展性:在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。
 * 4.解耦性:将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码
 * 5.符合开放-关闭原则:同一个适配器可以把适配者类和它的子类都适配到目标接口；可以为不同的目标接口实现不同的适配器，而不需要修改待适配类
 * 缺点:
 * 1.过多的使用适配器，会让系统非常零乱，不易整体进行把握
 * 类的适配器模式:
 * 优点:使用方便，代码简化,仅仅引入一个对象，并不需要额外的字段来引用Adaptee实例
 * 缺点:高耦合，灵活性低,使用对象继承的方式，是静态的定义方式
 * 对象的适配器模式:
 * 优点:灵活性高、低耦合,采用 “对象组合”的方式，是动态组合方式
 * 缺点:使用复杂,需要引入对象实例,特别是需要重新定义Adaptee行为时需要重新定义Adaptee的子类，并将适配器组合适配
 * 应用场景:
 * 1.系统需要复用现有类，而该类的接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
 * 2.多个组件功能类似，但接口不统一且可能会经常切换时，可使用适配器模式，使得客户端可以以统一的接口使用它们
 * 类和对象适配器模式的使用场景:
 * 1.灵活使用时：选择对象的适配器模式,类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。
 * 2.需要同时配源类和其子类：选择对象的适配器
 *          1.对于类适配器，由于适配器直接继承了Adaptee，使得适配器不能和Adaptee的子类一起工作，因为继承是静态的关系，当适配器继承了Adaptee后，就不可能再去处理 Adaptee的子类了；
 *          2.对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。换言之，同一个适配器可以把源类和它的子类都适配到目标接口。因为对象适配器采用的是对象组合的关系，只要对象类型正确，是不是子类都无所谓。
 * 3.需要重新定义Adaptee的部分行为：选择类适配器
 *          1.对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。
 *          2.对于对象适配器，要重定义Adaptee的行为比较困难，这种情况下，需要定义Adaptee的子类来实现重定义，然后让适配器组合子类。虽然重定义Adaptee的行为比较困难，但是想要增加一些新的行为则方便的很，而且新增加的行为可同时适用于所有的源。
 * 4.仅仅希望使用方便时：选择类适配器
 *          1.对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。
 *          2.对于对象适配器，需要额外的引用来间接得到Adaptee。
 * 总结:
 * 1.建议尽量使用对象的适配器模式，多用合成/聚合、少用继承。
 * 2.当然，具体问题具体分析，根据需要来选用合适的实现方式
 */
