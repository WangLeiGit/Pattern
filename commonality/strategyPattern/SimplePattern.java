package com.rxjava.commonality.strategyPattern;

/**
 * 作者：wanglei on 17/10/26 16:15
 * 邮箱：229846388@qq.com
 * 策略模式
 * 定义:
 * 1.定义一系列算法，将每个算法封装到具有公共接口的一系列策略类中，从而使它们可以相互替换，并让算法可以在不影响到客户端的情况下发生变化。
 * 2.简单来说，就是“准备一组算法，并将每一个算法封装起来，使得它们可以互换”
 * 作用（解决的问题）:
 * 1.使得客户端可以根据外部条件选择不同策略来解决不同问题
 * 2.策略模式仅仅封装算法（包括添加 & 删除），但策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定
 * 3.将算法的责任和本身进行解耦对算法进行封装，将算法的责任和算法本身分割开，委派给不同的对象管理。
 * 4.让算法和对象分开来，使得算法可以独立于使用它的客户而变化
 * 实例讲解:
 * a. 实例概况
 * 背景：小成有一家百货公司，最近在定年度的促销活动
 * 冲突：每个节日用同一个促销活动太枯燥，没吸引力
 * 解决方案：针对不同节目使用不同促销活动进行促销
 */
public class SimplePattern {

    public static void main(String[] args) {
        Context_SalesMan salesMan;

        salesMan = new Context_SalesMan("A");
        salesMan.SalesManShow();

        salesMan = new Context_SalesMan("B");
        salesMan.SalesManShow();

        salesMan = new Context_SalesMan("C");
        salesMan.SalesManShow();
    }
}

/**
 * 结果:
 * 为春节准备的促销活动A
 * 为春节准备的促销活动B
 * 为春节准备的促销活动C
 * 优点:
 * 1.策略类之间可以自由切换由于策略类都实现同一个接口，所以使它们之间可以自由切换。
 * 2.易于扩展增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“
 * 3.避免使用多重条件选择语句（if else），充分体现面向对象设计思想。
 * 缺点:
 * 1.客户端必须知道所有的策略类，并自行决定使用哪一个策略类。
 * 2.策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。
 * 应用场景:
 * 1.一个系统需要动态地在几种算法中选择一种的情况
 * 2.如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为
 * 3.如果一个对象有很多的行为，如果不使用合适的模式，这些行为就只好使用多重的if-else语句来实现，此时，可以使用策略模式，把这些行为转移到相应的具体策略类里面，就可以避免使用难以维护的多重条件选择语句，并体现面向对象涉及的概念。
 * 4.不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。
 */
